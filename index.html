<!doctype html>
<!--
Tangram: real-time WebGL rendering for OpenStreetMap

http://github.com/bcamper/tangram
http://mapzen.com
-->
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Mapzen Vector map</title>
<style>

body {
    margin: 0px;
    border: 0px;
    padding: 0px;
}

#map {
    background: rgba(0, 0, 0, 0);
}

</style>
<link rel="stylesheet" href="lib/leaflet-0.8-dev.css" />
</head>

<body>

<div id="map"></div>

<script src="lib/leaflet-0.8-dev.js"></script>
<script src="lib/dat.gui.min.js"></script>
<script src="dist/vector-map.debug.js"></script>
<script type="text/javascript" src="presets.json"></script>

<script>
var tiles_debug = false;

(function(){

var tile_source = 'mapzen'; // default source, can be overriden by URL

var tile_sources = {
    'mapzen': {
        source: {
            type: 'GeoJSONTileSource',
            url: 'http://vector.mapzen.com/osm/all/{z}/{x}/{y}.json'
        },
        layers: 'demos/gl_layers_json.js',
        styles: 'demos/gl_styles.js'
    },
    'mapzen-dev': {
        source: {
            type: 'GeoJSONTileSource',
            url: 'http://vector.dev.mapzen.com/osm/all/{z}/{x}/{y}.json'
        },
        layers: 'demos/gl_layers_json.js',
        styles: 'demos/gl_styles.js'
    },
    'mapzen-local': {
        source: {
            type: 'GeoJSONTileSource',
            url: 'http://localhost:8080/all/{z}/{x}/{y}.json'
        },
        layers: 'demos/gl_layers_json.js',
        styles: 'demos/gl_styles.js'
    },
    'mapzen-mvt': {
        source: {
            type: 'MapboxTileSource',
            url: 'http://vector.mapzen.com/osm/all/{z}/{x}/{y}.mapbox'
        },
        layers: 'demos/gl_layers_json.js',
        styles: 'demos/gl_styles.js'
    },
    'mapzen-topojson': {
        source: {
            type: 'TopoJSONTileSource',
            url: 'http://vector.mapzen.com/osm/all/{z}/{x}/{y}.topojson'
        },
        layers: 'demos/gl_layers_json.js',
        styles: 'demos/gl_styles.js'
    },
    'mapzen-canvas': {
        source: {
            type:'GeoJSONTileSource',
            url: 'http://vector.mapzen.com/osm/all/{z}/{x}/{y}.json'
        },
        layers: 'demos/canvas_layers.js',
        styles: 'demos/canvas_styles.js',
        renderer: 'CanvasRenderer'
    },
    'osm': {
        source: {
            type: 'GeoJSONTileSource',
            url: 'http://tile.openstreetmap.us/vectiles-all/{z}/{x}/{y}.json'
        },
        layers: 'demos/gl_layers_json.js',
        styles: 'demos/gl_styles.js'
    },
    'mapbox': {
        source: {
            type: 'MapboxTileSource',
            url: 'http://{s:[a,b,c,d]}.tiles.mapbox.com/v3/mapbox.mapbox-streets-v4/{z}/{x}/{y}.vector.pbf',
            max_zoom: 14
        },
        layers: 'demos/gl_layers_mvt.js',
        styles: 'demos/gl_styles.js'
    }
};

var locations = {
    'London': [51.508, -0.105, 15],
    'New York': [40.70531887544228, -74.00976419448853, 16],
    'Seattle': [47.609722, -122.333056, 15],
    'San Francisco': [37.79310914816524,-122.39872455596925, 15]
};

var osm_debug = false;


/*** URL parsing ***/

// URL hash pattern is one of:
// #[source]
// #[lat],[lng],[zoom]
// #[source],[lat],[lng],[zoom]
// #[source],[location name]

// check for any additional parameters in format &param=value
param_index = window.location.hash.indexOf("&");
if (param_index == -1) {
    var url_hash = window.location.hash.slice(1, window.location.hash.length).split(',');
} else {
    var url_hash = window.location.hash.slice(1, param_index).split(',');
    var url_params = window.location.hash.slice(param_index+1, window.location.hash.length).split('&');

    var params = []
    for (x in url_params) {
        params[url_params[x].split('=')[0]] = url_params[x].split('=')[1];
    }
}

// Get tile source from URL
if (url_hash.length >= 1 && tile_sources[url_hash[0]] != null) {
    tile_source = url_hash[0];
}

// Get location from URL
var map_start_location = locations['New York'];

if (url_hash.length == 3) {
    map_start_location = url_hash.slice(0, 3);
}
if (url_hash.length > 3) {
    map_start_location = url_hash.slice(1, 4);
}
else if (url_hash.length == 2) {
    map_start_location = locations[url_hash[1]];
}


//
// *** Map ***
//
var map = L.map('map', {
    maxZoom: 20,
    inertia: false,
    keyboard: true
});
map.attributionControl.setPrefix('');
var baseURL = "";
function updateURL() {
    var map_latlng = map.getCenter();
    baseURL = [tile_source, map_latlng.lat, map_latlng.lng, map.getZoom()].join(',');
    generateURL();    
}
function generateURL() {
    // log('generateurl');
    if (windowLoaded) {
        var url = baseURL;
        // add all params as query objects
        Object.keys(settings).forEach(function(key) {
            value = settings[key];
            // don't encode the value of the "share link" button or textfield
            // if (control != shareableLinkButtonName && control != shareableLinkTextfieldName) {
                // convert rgb to hex
                if (value.length == 3) {
                    value = rgbToHex(value[0], value[1], value[2]);
                    // update the settings object
                    settings[key] = value;
                }
                // concatenate each control's settings onto the baseurl
                url += "&" + key + "=" + value;
                
            // }
        });
        // log(settings);
        // log(url);
        window.location.hash = url;
        // log(window.location.hash.length);
    }

}
map.on('moveend', updateURL);

map.setView(map_start_location.slice(0, 2), map_start_location[2]);

// Resize map to window
function resizeMap () {
    document.getElementById('map').style.width = window.innerWidth + 'px';
    document.getElementById('map').style.height = window.innerHeight + 'px';
    map.invalidateSize(false);
}
window.addEventListener('resize', resizeMap);
resizeMap();


/*** Layer ***/

var layer = Tangram.leafletLayer({
    vectorRenderer: tile_sources[tile_source].renderer,
    vectorTileSource: tile_sources[tile_source].source,
    vectorLayers: tile_sources[tile_source].layers,
    vectorStyles: tile_sources[tile_source].styles,
    numWorkers: 2,
    // debug: true,
    attribution: 'Map data &copy; OpenStreetMap contributors | <a href="https://github.com/bcamper/tangram">Source Code</a>',
    unloadInvisibleTiles: false,
    updateWhenIdle: false
});

// For easier debugging access
window.layer = layer;
window.renderer = layer._renderer;
window.tiles = layer._renderer.tiles;

/***** GUI/debug controls *****/

var gl_controls = {
    projection: {
        projection: 'PROJECTION_PERSPECTIVE',
        options: {
            'None': '',
            'Perspective': 'PROJECTION_PERSPECTIVE',
            'Isometric': 'PROJECTION_ISOMETRIC',
            'Pop-Up': 'PROJECTION_POPUP'
        }
    },
    lighting: {
        lighting: 'LIGHTING_POINT',
        options: {
            'None': '',
            'Gradient': 'LIGHTING_POINT',
            'Flat': 'LIGHTING_DIRECTION',
            'Night': 'LIGHTING_NIGHT'
        }
    },
    effect: {
        effect: '',
        options: {
            'None': '',
            'Elevator': 'ANIMATION_ELEVATOR',
            'Wave': 'ANIMATION_WAVE',
            'Water animation': 'EFFECT_NOISE_ANIMATED',
            'Spotlight': 'EFFECT_SPOTLIGHT',
            'Color bleed': 'EFFECT_COLOR_BLEED'
        },
        animated: [
            'ANIMATION_ELEVATOR',
            'ANIMATION_WAVE',
            'EFFECT_NOISE_ANIMATED',
            'EFFECT_COLOR_BLEED'
        ]
    }
};
window.gl_controls = gl_controls;


function getQueryVariable(variable)
{
       var query = window.location.search.substring(1);
       var vars = query.split("&");
       for (var i=0;i<vars.length;i++) {
               var pair = vars[i].split("=");
               if(pair[0] == variable){return pair[1];}
       }
       return(false);
}

var url_ui = '';
var valid_url_ui = false;
// get gui preset from URL
if (url_hash.length > 4) {
    url_ui = url_hash.slice(4);
    for (p in presets.remembered) {
        // check that url_ui is actually a preset
        if (url_ui in presets.remembered) {
            valid_url_ui = true;
            presets["preset"] = url_ui;
        }
    }
}

var mygui = new dat.GUI({ autoPlace: true, load: presets });
mygui.domElement.parentNode.style.zIndex = 5;
// document.body.insertBefore(gui.domElement, document.body.firstChild);
window.gui = mygui;
mygui.remember(gui);

// set up #DEFINE controls

Object.keys(gl_controls).forEach(function(key) {
    mygui[key] = gl_controls[key].options;
    var control = mygui.add(mygui, key, gl_controls[key].options);
    control.onChange(function(value) {
        settings[key] = mygui[key];
        setGLProgramDefines();
        generateURL();
    });
});

// set up uniform controls

mygui.building_height = 1.0;
var heightVar = mygui.add(mygui, 'building_height', 0.0, 20.0);
heightVar.onChange(function(value) {
    setGLProgramUniform('1f', 'u_heightVar', value);
    settings["building_height"] = value;
    generateURL();
});

mygui.light_azimuth = 1.0;
var azimuthVar = mygui.add(mygui, 'light_azimuth', 0, 360);
azimuthVar.onChange(function(value) {
    setGLProgramUniform('1f', 'u_lightAzimuth', value);
    settings["light_azimuth"] = value;
    generateURL();
});

mygui.light_elevation = 1.0;
var elevationVar = mygui.add(mygui, 'light_elevation', 0.0, 1.0);
elevationVar.onChange(function(value) {
    setGLProgramUniform('1f', 'u_lightElevation', value);
    settings["light_elevation"] = value;
    generateURL();
});

// mygui.light_radius = 1.0;
// var radiusVar = mygui.add(mygui, 'light_radius', 0.0, 3.14159);
// radiusVar.onChange(function(value) {
//     setGLProgramUniform('1f', 'u_lightRadius', value);
//     settings["light_radius"] = value;
//     generateURL();
// });

mygui.lightIntensity = 1.0;
var lightIntensity = mygui.add(mygui, 'lightIntensity', -1.0, 1.0);
lightIntensity.onChange(function(value) {
    setGLProgramUniform('1f', 'u_lightIntensity', value);
    settings["lightIntensity"] = value;
    generateURL();
});

mygui.lightAmbient = 0.45;
var lightAmbient = mygui.add(mygui, 'lightAmbient', -1.0, 1.0);
lightAmbient.onChange(function(value) {
    setGLProgramUniform('1f', 'u_lightAmbient', value);
    settings["lightAmbient"] = value;
    generateURL();
});

mygui.lightHeight = 0.25;
var lightHeight = mygui.add(mygui, 'lightHeight', 0.0, 1.0);
lightHeight.onChange(function(value) {
    setGLProgramUniform('1f', 'u_lightHeight', value);
    settings["lightHeight"] = value;
    generateURL();
});
mygui.heightLimit = 0.45;
var heightLimit = mygui.add(mygui, 'heightLimit', 0.0, 3.0);
heightLimit.onChange(function(value) {
    setGLProgramUniform('1f', 'u_heightLimit', value);
    settings["heightLimit"] = value;
    generateURL();
});


mygui.light_position = [0.0, 0.0, 0.0];
var positionVar = mygui.addColor(mygui, 'light_position');
positionVar.onChange(function(value) {
    setGLProgramUniformColor('3f', 'u_lightPosition', value);
    settings["light_position"] = value;
    generateURL();
});

layers = [];
names = [];

// add a dat.gui color picker for each layer
for (x in layer._renderer.layers) {
    name = layer._renderer.layers[x].name;
    names[x] = name;
    mygui[name] = [0.0, 0.0, 0.0];
    var control = mygui.addColor(mygui, name);

    // dynamically set the associated pre-defined uniform
    control.onChange(function(x) {
        var u = 'testUniformColor' + x;
        return function(value) {
            // log(names[x]+": "+value);
            settings[names[x]] = value;
            generateURL();
            setGLProgramUniformColor('3f', u, value);
        };
    }(x));  // this immediately calls the function. not sure why this works
}

// generate a sharable url from the controls

// shareableLinkButtonName = "Link to map…";
// shareableLinkTextfieldName = "link:";

// mygui[shareableLinkButtonName] = function(){
// function generateShareURL() {
//     url = window.location;
//     Object.keys(mygui.__controllers).forEach(function(key) {
//         control = mygui.__controllers[key].property;
//         value = mygui[control];
//         // don't encode the value of the "share link" button or textfield
//         if (control != shareableLinkButtonName && control != shareableLinkTextfieldName) {
//             // convert rgb to hex
//             if (value.length == 3) {
//                 value = rgbToHex(value[0], value[1], value[2]);
//             }
//             // concatenate each control's settings onto the baseurl
//             url += "&" + control + "=" + value
//         }
//     });


    // // add a new textfield to the gui, containing the url
    // // if the textfield exists, this will update its value --
    // // otherwise it adds the property to the gui
    // linked = false;
    // mygui[shareableLinkTextfieldName] = url;

    // // if it's the first time, add the control, referencing the property
    // if (!linked) {
    //     mygui.add(mygui, shareableLinkTextfieldName);
    //     linked = true; 
    // } else {
    //     // blank the textfield to show that something's changing,
    //     // then update the textfield with the new value
    //     mygui[shareableLinkTextfieldName] = "";
    //     refreshLinkTextfield()
    //     setTimeout(function() {
    //         mygui[shareableLinkTextfieldName] = url;
    //         refreshLinkTextfield();}
    //     , 250);
    // }

//     window.prompt("Copy to clipboard: Ctrl+C, Enter", url);
// }

// function refreshLinkTextfield() {
//     for (i in mygui.__controllers){
//         if (mygui.__controllers[i].property == shareableLinkTextfieldName) {
//             mygui.__controllers[i].updateDisplay();
//         }
//     }
// }

// }

// var generateShareURL = mygui.add(mygui, shareableLinkButtonName);



// *** Load presets ***

// if there's no valid preset parameter in the url, check for passed params
if (!valid_url_ui && params) {
    Object.keys(params).forEach(function(key) {
        mygui[key] = params[key];
    });
    for (i in mygui.__controllers){
        mygui.__controllers[i].updateDisplay();
    }
}

// save gui settings in an array for easy access, for generateURL()
var settings = new Object();
Object.keys(mygui.__controllers).forEach(function(key) {
    settings[mygui.__controllers[key].property] = mygui[mygui.__controllers[key].property];
});



/*** SET SHADER VARIABLES ***/

function updateUniforms() {
    for (x in layer._renderer.layers) {
        var u = 'testUniformColor' + x;
        function testfunc() {
            setGLProgramUniformColor('3f', u, mygui[layer._renderer.layers[x].name]);
        }(testfunc());
    };
    setGLProgramUniform('1f', 'u_heightVar', mygui.building_height);

    setGLProgramUniform('1f', 'u_lightAzimuth', mygui.light_azimuth);
    setGLProgramUniform('1f', 'u_lightElevation', mygui.light_elevation);
    setGLProgramUniform('1f', 'u_lightIntensity', mygui.lightIntensity);
    setGLProgramUniform('1f', 'u_lightAmbient', mygui.lightAmbient);

    setGLProgramUniform('1f', 'u_lightHeight', mygui.lightHeight);
    setGLProgramUniform('1f', 'u_heightLimit', mygui.heightLimit);
}

function setGLProgramUniform (type, name, value) {
    for (var m in layer._renderer.render_modes) {
        layer._renderer.gl.useProgram(layer._renderer.render_modes[m].gl_program.program);
        layer._renderer.render_modes[m].gl_program.uniform(type, name, value);
    }
    layer._renderer.dirty = true;
}

function setGLProgramUniformColor (type, name, value) {
    for (var m in layer._renderer.render_modes) {
        layer._renderer.gl.useProgram(layer._renderer.render_modes[m].gl_program.program);
        // handle web colors, in case they are manually entered into the gui
        if (value[0].toString()[0] == "#" ) value = hexToRgb(value);
        layer._renderer.render_modes[m].gl_program.uniform(type, name, value[0]/255, value[1]/255, value[2]/255);
    }

    layer._renderer.dirty = true;
}

function setGLProgramDefines () {
    var animated = false;
    Object.keys(gl_controls).forEach(function(key) {
        setGLProgramDefinesForOptionSet(mygui[key], gl_controls[key].options);

        // Animated?
        if (gl_controls[key].animated && gl_controls[key].animated.indexOf(mygui[key]) > -1) {
            animated = true;
        }
    });
    layer._renderer.continuous_animation = animated;

    for (var m in layer._renderer.render_modes) {
        var gl_program = layer._renderer.render_modes[m].gl_program;
        gl_program.compile();
    }
    layer._renderer.dirty = true;
}

function setGLProgramDefinesForOptionSet (current_value, options) {
    for (var i in options) {
        Tangram.GL.Program.defines[options[i]] = ((options[i] == current_value) && options[i] != '');
    }
}

/*** HELPER FUNCTIONS ***/

function componentToHex(c) {
    c = Math.round(c);
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}

function rgbToHex(r, g, b) {
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}

function hexToRgb(hex) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : null;
}

function log(v) {
    console.log(v);
}


/***** Render loop *****/

var osm_layer; // global so it's accessible on console for debugging
window.addEventListener('load', function () {
    layer.addTo(map);
    setGLProgramDefines();

    if (osm_debug == true) {
        osm_layer =
            L.tileLayer(
                'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                { opacity: 0.5 })
            .bringToFront()
            .addTo(map);
    }

    frameLoop();
});

function frame () {
    layer.render();
}

function frameLoop () {
    frame();
    requestAnimationFrame(frameLoop);
}

// Cross-browser compatibility for requestAnimationFrame
(function requestAnimationFrameCompatibility () {
    if (window.requestAnimationFrame == undefined) {
        window.requestAnimationFrame = (function () {
            return (
                window.requestAnimationFrame       ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame    ||
                window.oRequestAnimationFrame      ||
                window.msRequestAnimationFrame     ||
                function (callback) {
                   window.setTimeout(callback, 1000 / 60);
                }
            );
        })();
    }
}());
var windowLoaded = false;
    // refresh canvas to apply preloaded settings
    window.onload = function() {
        windowLoaded = true;
        generateURL();
        updateUniforms();
        document.getElementById('map').focus();
    }


}());


</script>
</body>
</html>
